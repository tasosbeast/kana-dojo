'use client';
import { useState, useEffect, useRef, useMemo, useCallback } from 'react';
import { CircleCheck, CircleX, CircleArrowRight } from 'lucide-react';
import clsx from 'clsx';
import { motion } from 'framer-motion';
import { toHiragana } from 'wanakana';
import { IVocabObj } from '@/features/Vocabulary/store/useVocabStore';
import { useClick, useCorrect, useError } from '@/shared/hooks/useAudio';
import GameIntel from '@/shared/components/Game/GameIntel';
import { useStopwatch } from 'react-timer-hook';
import useStats from '@/shared/hooks/useStats';
import useStatsStore from '@/features/Progress/store/useStatsStore';
import { useShallow } from 'zustand/react/shallow';
import Stars from '@/shared/components/Game/Stars';
import AnswerSummary from '@/shared/components/Game/AnswerSummary';
import SSRAudioButton from '@/shared/components/audio/SSRAudioButton';
import FuriganaText from '@/shared/components/text/FuriganaText';
import { useCrazyModeTrigger } from '@/features/CrazyMode/hooks/useCrazyModeTrigger';
import { getGlobalAdaptiveSelector } from '@/shared/lib/adaptiveSelection';
import { ActionButton } from '@/shared/components/ui/ActionButton';

// Get the global adaptive selector for weighted character selection
const adaptiveSelector = getGlobalAdaptiveSelector();

// Bottom bar states
type BottomBarState = 'check' | 'correct' | 'wrong';

interface VocabInputGameProps {
  selectedWordObjs: IVocabObj[];
  isHidden: boolean;
  isReverse?: boolean;
}

const VocabInputGame = ({
  selectedWordObjs,
  isHidden,
  isReverse = false
}: VocabInputGameProps) => {
  const {
    score,
    setScore,
    incrementVocabularyCorrect,
    recordAnswerTime,
    incrementWrongStreak,
    resetWrongStreak
  } = useStatsStore(
    useShallow(state => ({
      score: state.score,
      setScore: state.setScore,
      incrementVocabularyCorrect: state.incrementVocabularyCorrect,
      recordAnswerTime: state.recordAnswerTime,
      incrementWrongStreak: state.incrementWrongStreak,
      resetWrongStreak: state.resetWrongStreak
    }))
  );

  const speedStopwatch = useStopwatch({ autoStart: false });

  const {
    incrementCorrectAnswers,
    incrementWrongAnswers,
    addCharacterToHistory,
    addCorrectAnswerTime,
    incrementCharacterScore
  } = useStats();

  const { playClick } = useClick();
  const { playCorrect } = useCorrect();
  const { playErrorTwice } = useError();
  const { trigger: triggerCrazyMode } = useCrazyModeTrigger();

  const inputRef = useRef<HTMLTextAreaElement>(null);
  const buttonRef = useRef<HTMLButtonElement>(null);

  const [inputValue, setInputValue] = useState('');
  const [bottomBarState, setBottomBarState] = useState<BottomBarState>('check');

  // Quiz type: 'meaning' or 'reading'
  const [quizType, setQuizType] = useState<'meaning' | 'reading'>('meaning');

  // State management based on mode - uses weighted selection for adaptive learning
  const [correctChar, setCorrectChar] = useState(() => {
    if (selectedWordObjs.length === 0) return '';
    const sourceArray = isReverse
      ? selectedWordObjs.map(obj => obj.meanings[0])
      : selectedWordObjs.map(obj => obj.word);
    const selected = adaptiveSelector.selectWeightedCharacter(sourceArray);
    adaptiveSelector.markCharacterSeen(selected);
    return selected;
  });

  // Find the target character/meaning based on mode
  const correctWordObj = isReverse
    ? selectedWordObjs.find(obj => obj.meanings[0] === correctChar)
    : selectedWordObjs.find(obj => obj.word === correctChar);

  const [currentWordObj, setCurrentWordObj] = useState<IVocabObj>(
    correctWordObj as IVocabObj
  );

  // Determine target based on quiz type and mode
  const targetChar =
    quizType === 'meaning'
      ? isReverse
        ? correctWordObj?.word
        : correctWordObj?.meanings
      : correctWordObj?.reading;

  const [displayAnswerSummary, setDisplayAnswerSummary] = useState(false);

  useEffect(() => {
    if (inputRef.current && bottomBarState === 'check') {
      inputRef.current.focus();
    }
  }, [bottomBarState]);

  // Keyboard shortcut for Enter/Space to trigger button
  useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      const isEnter = (event.ctrlKey || event.metaKey) && event.key === 'Enter';
      const isSpace = event.code === 'Space' || event.key === ' ';

      if (isEnter) {
        if (bottomBarState !== 'check') {
          buttonRef.current?.click();
        }
      } else if (isSpace) {
        // Only trigger button for continue state.
        if (bottomBarState === 'correct') {
          event.preventDefault();
          buttonRef.current?.click();
        }
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [bottomBarState]);

  useEffect(() => {
    if (isHidden) speedStopwatch.pause();
  }, [isHidden]);

  if (!selectedWordObjs || selectedWordObjs.length === 0) {
    return null;
  }

  const handleEnter = (e: React.KeyboardEvent<HTMLTextAreaElement>) => {
    if (
      e.key === 'Enter' &&
      inputValue.trim().length &&
      bottomBarState !== 'correct'
    ) {
      handleCheck();
    }
  };

  const isInputCorrect = (input: string): boolean => {
    if (quizType === 'meaning') {
      if (!isReverse) {
        return (
          Array.isArray(targetChar) && targetChar.includes(input.toLowerCase())
        );
      } else {
        return input === targetChar;
      }
    } else {
      const targetReading = typeof targetChar === 'string' ? targetChar : '';
      const inputAsHiragana = toHiragana(input);
      const targetAsHiragana = toHiragana(targetReading);
      return inputAsHiragana === targetAsHiragana || input === targetReading;
    }
  };

  const handleCheck = () => {
    if (inputValue.trim().length === 0) return;
    const trimmedInput = inputValue.trim();

    playClick();

    if (isInputCorrect(trimmedInput)) {
      handleCorrectAnswer(trimmedInput);
    } else {
      handleWrongAnswer();
    }
  };

  const handleCorrectAnswer = (userInput: string) => {
    speedStopwatch.pause();
    const answerTimeMs = speedStopwatch.totalMilliseconds;
    addCorrectAnswerTime(answerTimeMs / 1000);
    recordAnswerTime(answerTimeMs);
    speedStopwatch.reset();
    setCurrentWordObj(correctWordObj as IVocabObj);

    playCorrect();
    addCharacterToHistory(correctChar);
    incrementCharacterScore(correctChar, 'correct');
    incrementCorrectAnswers();
    setScore(score + 1);

    triggerCrazyMode();
    adaptiveSelector.updateCharacterWeight(correctChar, true);
    incrementVocabularyCorrect();
    resetWrongStreak();
    setBottomBarState('correct');
    setDisplayAnswerSummary(true);
  };

  const handleWrongAnswer = () => {
    setInputValue('');
    playErrorTwice();

    incrementCharacterScore(correctChar, 'wrong');
    incrementWrongAnswers();
    if (score - 1 < 0) {
      setScore(0);
    } else {
      setScore(score - 1);
    }
    triggerCrazyMode();
    adaptiveSelector.updateCharacterWeight(correctChar, false);
    incrementWrongStreak();
    setBottomBarState('wrong');
  };

  const generateNewCharacter = () => {
    const sourceArray = isReverse
      ? selectedWordObjs.map(obj => obj.meanings[0])
      : selectedWordObjs.map(obj => obj.word);

    const newChar = adaptiveSelector.selectWeightedCharacter(
      sourceArray,
      correctChar
    );
    adaptiveSelector.markCharacterSeen(newChar);
    setCorrectChar(newChar);

    // Toggle quiz type for the next question
    setQuizType(prev => (prev === 'meaning' ? 'reading' : 'meaning'));
  };

  const handleContinue = useCallback(() => {
    playClick();
    setInputValue('');
    setDisplayAnswerSummary(false);
    generateNewCharacter();
    setBottomBarState('check');
    speedStopwatch.reset();
    speedStopwatch.start();
  }, [playClick]);

  const gameMode = isReverse ? 'reverse input' : 'input';
  const displayCharLang = isReverse && quizType === 'meaning' ? 'en' : 'ja';
  const inputLang = quizType === 'reading' ? 'ja' : isReverse ? 'ja' : 'en';
  const textSize = isReverse ? 'text-5xl sm:text-7xl' : 'text-5xl md:text-8xl';
  const canCheck = inputValue.trim().length > 0 && bottomBarState !== 'correct';
  const showContinue = bottomBarState === 'correct';
  const showFeedback = bottomBarState !== 'check';

  // For Bottom Bar feedback
  const feedbackText = isReverse
    ? targetChar
    : Array.isArray(targetChar)
      ? targetChar[0]
      : targetChar;

  return (
    <div
      className={clsx(
        'flex w-full flex-col items-center gap-10 sm:w-4/5',
        isHidden ? 'hidden' : ''
      )}
    >
      <GameIntel gameMode={gameMode} />

      {displayAnswerSummary ? (
        <AnswerSummary
          payload={currentWordObj}
          setDisplayAnswerSummary={setDisplayAnswerSummary}
          feedback={<></>}
          isEmbedded={true}
        />
      ) : (
        <>
          <div className='flex flex-col items-center gap-4'>
            <span className='mb-2 text-sm text-[var(--secondary-color)]'>
              {quizType === 'meaning'
                ? isReverse
                  ? 'What is the meaning?'
                  : 'What is the meaning?'
                : 'What is the reading?'}
            </span>
            <div className='flex flex-row items-center gap-1'>
              <motion.div
                initial={{ opacity: 0, y: -30, scale: 0.95 }}
                animate={{ opacity: 1, y: 0, scale: 1 }}
                transition={{
                  type: 'spring',
                  stiffness: 150,
                  damping: 20,
                  mass: 1,
                  duration: 0.5
                }}
                key={correctChar + quizType}
                className='flex flex-row items-center gap-1'
              >
                <FuriganaText
                  text={correctChar}
                  reading={
                    !isReverse && quizType === 'meaning'
                      ? correctWordObj?.reading
                      : undefined
                  }
                  className={clsx(textSize, 'text-center')}
                  lang={displayCharLang}
                />
                {!isReverse && (
                  <SSRAudioButton
                    text={correctChar}
                    variant='icon-only'
                    size='sm'
                    className='bg-[var(--card-color)] text-[var(--secondary-color)]'
                  />
                )}
              </motion.div>
            </div>
          </div>

          <textarea
            ref={inputRef as any}
            value={inputValue}
            placeholder='Type your answer...'
            disabled={showContinue}
            rows={2}
            className={clsx(
              'w-full max-w-xs sm:max-w-sm md:max-w-md',
              'rounded-2xl px-5 py-4',
              'rounded-2xl border-1 border-[var(--border-color)] bg-[var(--card-color)]',
              'text-top text-left text-lg font-medium lg:text-xl',
              'text-[var(--secondary-color)] placeholder:text-base placeholder:font-normal placeholder:text-[var(--secondary-color)]/40',
              'resize-none focus:outline-none',
              'transition-colors duration-200 ease-out',
              showContinue && 'cursor-not-allowed opacity-60'
            )}
            onChange={e => setInputValue(e.target.value)}
            onKeyDown={e => {
              if (e.key === 'Enter') {
                e.preventDefault();
                handleEnter(e as any);
              }
            }}
            lang={inputLang}
          />
        </>
      )}

      <Stars />

      {/* Bottom Bar */}
      <div
        className={clsx(
          'right-0 left-0 w-full',
          'border-t-2 border-[var(--border-color)] bg-[var(--card-color)]',
          'absolute bottom-0 z-10 px-2 py-2 sm:py-3 md:bottom-6 md:px-12 md:pt-2 md:pb-4',
          'flex min-h-20 flex-row items-center justify-center'
        )}
      >
        <div className='flex w-1/2 items-center justify-center'>
          <div
            className={clsx(
              'flex items-center gap-2 transition-all duration-500 sm:gap-3 md:gap-4',
              showFeedback
                ? 'translate-x-0 opacity-100'
                : 'pointer-events-none -translate-x-4 opacity-0 sm:-translate-x-8'
            )}
          >
            {bottomBarState === 'correct' ? (
              <CircleCheck className='h-10 w-10 text-[var(--main-color)] sm:h-12 sm:w-12' />
            ) : (
              <CircleX className='h-10 w-10 text-[var(--main-color)] sm:h-12 sm:w-12' />
            )}
            <div className='flex flex-col'>
              <span className='text-lg text-[var(--secondary-color)] sm:text-2xl'>
                {bottomBarState === 'correct'
                  ? 'Nicely done!'
                  : 'Wrong! Correct answer:'}
              </span>
              <span className='text-sm text-[var(--main-color)] sm:text-lg'>
                {feedbackText}
              </span>
            </div>
          </div>
        </div>

        <div className='flex w-1/2 flex-row items-end justify-center gap-3'>
          <div className='flex h-[68px] items-end sm:h-[72px]'>
            <ActionButton
              ref={buttonRef}
              borderBottomThickness={12}
              borderRadius='3xl'
              className={clsx(
                'w-auto px-6 py-2.5 text-lg font-medium transition-all duration-150 sm:px-12 sm:py-3 sm:text-xl',
                !canCheck && !showContinue && 'cursor-default opacity-60'
              )}
              onClick={showContinue ? handleContinue : handleCheck}
            >
              <span className='max-sm:hidden'>
                {showContinue ? 'continue' : 'check'}
              </span>
              {showContinue ? (
                <CircleArrowRight className='h-8 w-8' />
              ) : (
                <CircleCheck className='h-8 w-8' />
              )}
            </ActionButton>
          </div>
        </div>
      </div>

      <div className='h-32' />
    </div>
  );
};

export default VocabInputGame;
